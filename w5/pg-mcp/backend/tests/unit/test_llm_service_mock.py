"""
LLM service tests with mocking.

This module tests the LLM service with mocked API calls to avoid
actual OpenAI API usage and ensure reliable testing.
"""

import pytest
from unittest.mock import Mock, AsyncMock, patch
from app.services.llm import LLMService
from app.core.errors import LLMServiceError, ValidationError


@pytest.mark.unit
class TestLLMServiceBasics:
    """Test basic LLM service functionality."""

    @pytest.mark.asyncio
    async def test_llm_service_initialization(self):
        """Test that LLM service initializes correctly."""
        service = LLMService()
        assert service is not None
        assert service.client is not None
        assert service.model is not None

    @pytest.mark.asyncio
    async def test_llm_service_without_api_key(self):
        """Test LLM service behavior when API key is not configured."""
        with patch('app.services.llm.settings.openai_api_key', ''):
            service = LLMService()
            # Service should still initialize but will fail when trying to generate
            assert service is not None


@pytest.mark.unit
class TestSQLGenerationWithMocking:
    """Test SQL generation with mocked OpenAI API calls."""

    @pytest.mark.asyncio
    async def test_successful_sql_generation(self):
        """Test successful SQL generation from natural language."""
        service = LLMService()

        # Mock the OpenAI API response
        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "SELECT * FROM users WHERE age > 18"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            database_metadata = {
                "database": "testdb",
                "tables": [
                    {
                        "name": "users",
                        "schema": "public",
                        "columns": [
                            {"name": "id", "data_type": "integer", "is_primary_key": True},
                            {"name": "name", "data_type": "text", "is_nullable": False},
                            {"name": "age", "data_type": "integer", "is_nullable": True}
                        ]
                    }
                ],
                "views": []
            }

            result = await service.generate_sql(
                "Show me all users older than 18",
                database_metadata
            )

            assert result is not None
            assert "SELECT" in result.upper()
            assert "users" in result.lower()
            mock_create.assert_called_once()

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_sql_generation_with_markdown_formatting(self):
        """Test that SQL generation handles markdown code blocks."""
        service = LLMService()

        # Mock response with markdown formatting
        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "```sql\nSELECT * FROM users WHERE id = 1\n```"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            result = await service.generate_sql(
                "Get user with id 1",
                {"database": "test", "tables": [], "views": []}
            )

            assert result is not None
            assert "```" not in result  # Markdown should be stripped
            assert "SELECT" in result.upper()

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_sql_generation_validation_failure(self):
        """Test that invalid SQL generated by LLM is caught."""
        service = LLMService()

        # Mock response with invalid SQL
        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "INVALID SQL QUERY HERE"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            with pytest.raises(LLMServiceError):
                await service.generate_sql(
                    "Get all users",
                    {"database": "test", "tables": [], "views": []}
                )

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_sql_generation_with_retries(self):
        """Test SQL generation with automatic retry on validation failure."""
        service = LLMService()

        # First attempt fails validation, second succeeds
        first_response = Mock()
        first_response.choices = [Mock()]
        first_response.choices[0].message.content = "INVALID SQL"

        second_response = Mock()
        second_response.choices = [Mock()]
        second_response.choices[0].message.content = "SELECT * FROM users"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.side_effect = [first_response, second_response]

            result = await service.generate_and_validate_sql(
                "Get all users",
                {"database": "test", "tables": [], "views": []},
                max_retries=2
            )

            assert result is not None
            assert "SELECT" in result.upper()
            assert mock_create.call_count == 2


@pytest.mark.unit
class TestLLMErrorHandling:
    """Test LLM service error handling and edge cases."""

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_empty_natural_language_query(self):
        """Test that empty queries are rejected before API call."""
        service = LLMService()

        with pytest.raises(ValidationError):
            await service.generate_sql(
                "",
                {"database": "test", "tables": [], "views": []}
            )

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_whitespace_only_query(self):
        """Test that whitespace-only queries are rejected."""
        service = LLMService()

        with pytest.raises(ValidationError):
            await service.generate_sql(
                "   \n\t  ",
                {"database": "test", "tables": [], "views": []}
            )

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_api_key_error_handling(self):
        """Test behavior when API key is missing."""
        with patch('app.services.llm.settings.openai_api_key', ''):
            service = LLMService()

            with pytest.raises(LLMServiceError) as exc_info:
                await service.generate_sql(
                    "Get users",
                    {"database": "test", "tables": [], "views": []}
                )

            assert "not configured" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_api_timeout_handling(self):
        """Test handling of API timeout errors."""
        service = LLMService()

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.side_effect = TimeoutError("API timeout")

            with pytest.raises(LLMServiceError):
                await service.generate_sql(
                    "Get users",
                    {"database": "test", "tables": [], "views": []}
                )

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_api_rate_limit_handling(self):
        """Test handling of rate limit errors."""
        service = LLMService()

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            # Simulate rate limit error
            mock_create.side_effect = Exception("Rate limit exceeded: 429")

            with pytest.raises(LLMServiceError):
                await service.generate_sql(
                    "Get users",
                    {"database": "test", "tables": [], "views": []}
                )


@pytest.mark.unit
class TestMetadataContextBuilding:
    """Test the metadata context building functionality."""

    @pytest.mark.asyncio
    async def test_empty_metadata(self):
        """Test handling of empty database metadata."""
        service = LLMService()
        context = service.build_metadata_context({})

        assert context is not None
        assert "No database schema available" in context or "No tables" in context

    @pytest.mark.asyncio
    async def test_metadata_with_tables(self):
        """Test building context with table information."""
        service = LLMService()

        metadata = {
            "database": "testdb",
            "tables": [
                {
                    "name": "users",
                    "schema": "public",
                    "columns": [
                        {"name": "id", "data_type": "integer", "is_primary_key": True, "is_nullable": False},
                        {"name": "name", "data_type": "text", "is_primary_key": False, "is_nullable": False}
                    ]
                }
            ],
            "views": []
        }

        context = service.build_metadata_context(metadata)

        assert "users" in context
        assert "public" in context
        assert "id" in context
        assert "name" in context

    @pytest.mark.asyncio
    async def test_metadata_with_views(self):
        """Test building context with view information."""
        service = LLMService()

        metadata = {
            "database": "testdb",
            "tables": [],
            "views": [
                {
                    "name": "user_summary",
                    "schema": "public",
                    "columns": [
                        {"name": "user_count", "data_type": "bigint"},
                        {"name": "avg_age", "data_type": "numeric"}
                    ]
                }
            ]
        }

        context = service.build_metadata_context(metadata)

        assert "user_summary" in context
        assert "public" in context

    @pytest.mark.asyncio
    async def test_metadata_with_complex_schema(self):
        """Test building context with complex schema."""
        service = LLMService()

        metadata = {
            "database": "ecommerce",
            "tables": [
                {
                    "name": "users",
                    "schema": "public",
                    "columns": [
                        {"name": "id", "data_type": "integer", "is_primary_key": True, "is_nullable": False},
                        {"name": "email", "data_type": "varchar(255)", "is_primary_key": False, "is_nullable": False}
                    ]
                },
                {
                    "name": "orders",
                    "schema": "public",
                    "columns": [
                        {"name": "id", "data_type": "integer", "is_primary_key": True, "is_nullable": False},
                        {"name": "user_id", "data_type": "integer", "is_primary_key": False, "is_nullable": False}
                    ]
                }
            ],
            "views": [
                {
                    "name": "order_summary",
                    "schema": "analytics",
                    "columns": [
                        {"name": "total_orders", "data_type": "bigint"}
                    ]
                }
            ]
        }

        context = service.build_metadata_context(metadata)

        assert "users" in context
        assert "orders" in context
        assert "order_summary" in context
        assert "public" in context
        assert "analytics" in context


@pytest.mark.unit
class TestPromptGeneration:
    """Test SQL generation prompt creation."""

    @pytest.mark.asyncio
    async def test_prompt_includes_metadata(self):
        """Test that the generated prompt includes database metadata."""
        service = LLMService()

        metadata = {
            "database": "testdb",
            "tables": [
                {
                    "name": "users",
                    "schema": "public",
                    "columns": [{"name": "id", "data_type": "integer"}]
                }
            ],
            "views": []
        }

        prompt = service._create_sql_generation_prompt(
            "Show me all users",
            service.build_metadata_context(metadata)
        )

        assert "users" in prompt
        assert "public" in prompt
        assert "Show me all users" in prompt

    @pytest.mark.asyncio
    async def test_prompt_includes_rules(self):
        """Test that the prompt includes SQL generation rules."""
        service = LLMService()

        prompt = service._create_sql_generation_prompt(
            "Get users",
            "Database: test\nTables:\n  users (id, name)"
        )

        assert "SELECT" in prompt
        assert "PostgreSQL" in prompt
        # Should have rules about proper SQL generation


@pytest.mark.integration
class TestLLMServiceIntegration:
    """Integration tests for LLM service with realistic scenarios."""

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_complete_query_generation_flow(self):
        """Test the complete flow from natural language to validated SQL."""
        service = LLMService()

        # Mock successful API response
        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "SELECT id, name FROM users WHERE status = 'active'"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            metadata = {
                "database": "mydb",
                "tables": [
                    {
                        "name": "users",
                        "schema": "public",
                        "columns": [
                            {"name": "id", "data_type": "integer"},
                            {"name": "name", "data_type": "text"},
                            {"name": "status", "data_type": "varchar(20)"}
                        ]
                    }
                ],
                "views": []
            }

            result = await service.generate_and_validate_sql(
                "Get active users",
                metadata
            )

            assert result is not None
            assert "SELECT" in result.upper()
            assert "users" in result.lower()
            mock_create.assert_called_once()

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_complex_query_with_joins(self):
        """Test generation of queries with JOINs."""
        service = LLMService()

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "SELECT u.name, o.order_date FROM users u JOIN orders o ON u.id = o.user_id"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            metadata = {
                "database": "ecommerce",
                "tables": [
                    {
                        "name": "users",
                        "schema": "public",
                        "columns": [
                            {"name": "id", "data_type": "integer"},
                            {"name": "name", "data_type": "text"}
                        ]
                    },
                    {
                        "name": "orders",
                        "schema": "public",
                        "columns": [
                            {"name": "id", "data_type": "integer"},
                            {"name": "user_id", "data_type": "integer"},
                            {"name": "order_date", "data_type": "timestamp"}
                        ]
                    }
                ],
                "views": []
            }

            result = await service.generate_sql(
                "Get users and their orders",
                metadata
            )

            assert result is not None
            assert "JOIN" in result.upper()


@pytest.mark.unit
class TestLLMServiceEdgeCases:
    """Test edge cases and unusual scenarios."""

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_very_long_natural_language_query(self):
        """Test handling of very long natural language queries."""
        service = LLMService()

        long_query = "Get me " + "all the users " * 50 + "from the database"

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "SELECT * FROM users"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            result = await service.generate_sql(
                long_query,
                {"database": "test", "tables": [], "views": []}
            )

            assert result is not None

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_special_characters_in_query(self):
        """Test handling of special characters in natural language."""
        service = LLMService()

        special_query = "Get users where name contains @#$%^&*()"

        mock_response = Mock()
        mock_response.choices = [Mock()]
        mock_response.choices[0].message.content = "SELECT * FROM users"

        with patch.object(service.client.chat.completions, 'create', new_callable=AsyncMock) as mock_create:
            mock_create.return_value = mock_response

            result = await service.generate_sql(
                special_query,
                {"database": "test", "tables": [], "views": []}
            )

            assert result is not None

    @pytest.mark.asyncio
    @pytest.mark.asyncio
    async def test_unicode_characters_in_metadata(self):
        """Test handling of Unicode characters in table/column names."""
        service = LLMService()

        metadata = {
            "database": "test",
            "tables": [
                {
                    "name": "用户",
                    "schema": "public",
                    "columns": [
                        {"name": "id", "data_type": "integer"},
                        {"name": "名字", "data_type": "text"}
                    ]
                }
            ],
            "views": []
        }

        context = service.build_metadata_context(metadata)
        assert "用户" in context
        assert "名字" in context
