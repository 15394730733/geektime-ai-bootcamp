/**
 * NaturalLanguageInput SQL Editability Property-Based Tests
 * 
 * **Feature: database-query-tool, Property 17: Generated SQL editability**
 * **Validates: Requirements 7.5**
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { NaturalLanguageInput } from '../NaturalLanguageInput';
import { NaturalLanguageQueryResult } from '../../services/api';

// Mock Monaco Editor for property testing
vi.mock('@monaco-editor/react', () => ({
  default: ({ value, onChange, onMount, language, options, ...props }: any) => {
    React.useEffect(() => {
      if (onMount) {
        const mockEditor = {
          focus: vi.fn(),
          addCommand: vi.fn(),
        };
        onMount(mockEditor);
      }
    }, [onMount]);

    return (
      <div
        data-testid="monaco-editor"
        data-language={language}
        data-value={value}
        {...props}
      >
        <textarea 
          data-testid="monaco-textarea"
          value={value} 
          onChange={(e) => onChange?.(e.target.value)} 
        />
      </div>
    );
  },
}));

// Mock QueryResults component
vi.mock('../QueryResults', () => ({
  QueryResults: ({ columns, rows, rowCount, executionTimeMs, loading, query }: any) => (
    <div data-testid="query-results">
      <div data-testid="results-query">{query}</div>
    </div>
  ),
}));

describe('NaturalLanguageInput SQL Editability Property Tests', () => {
  const mockOnSubmit = vi.fn();
  const mockOnExecuteSQL = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  /**
   * Property 17: Generated SQL editability
   * For any SQL generated by the LLM service, the user should be able to edit it before execution.
   * **Validates: Requirements 7.5**
   */
  it('Property 17: Generated SQL editability - should allow editing of any generated SQL', async () => {
    // Test with a representative set of generated SQL queries
    const generatedSQLQueries = [
      'SELECT * FROM users',
      'SELECT name, email FROM customers WHERE active = true',
      'SELECT COUNT(*) FROM orders GROUP BY status',
      'SELECT p.name, c.name FROM products p JOIN categories c ON p.category_id = c.id',
      'SELECT * FROM logs WHERE created_at > NOW() - INTERVAL \'1 day\'',
    ];

    for (const originalSQL of generatedSQLQueries) {
      // Mock successful LLM response with generated SQL
      const mockLLMResult: NaturalLanguageQueryResult = {
        generated_sql: originalSQL,
        columns: ['result'],
        rows: [['test']],
        row_count: 1,
        execution_time_ms: 100,
        truncated: false,
      };

      mockOnSubmit.mockResolvedValueOnce(mockLLMResult);

      const { unmount } = render(
        <NaturalLanguageInput
          onSubmit={mockOnSubmit}
          onExecuteSQL={mockOnExecuteSQL}
        />
      );

      // Step 1: Submit natural language query to generate SQL
      const textarea = screen.getByPlaceholderText(/describe what data you want to see/i);
      fireEvent.change(textarea, { target: { value: 'test query' } });

      const submitButton = screen.getByRole('button', { name: /convert to sql/i });
      fireEvent.click(submitButton);

      // Wait for SQL to be generated and displayed in the Generated SQL card
      await waitFor(() => {
        // Look for the Generated SQL card specifically
        expect(screen.getByText('Generated SQL')).toBeInTheDocument();
        // Verify SQL appears in the view mode (pre element)
        const preElement = document.querySelector('pre');
        expect(preElement).toHaveTextContent(originalSQL);
      });

      // Step 2: Verify that the Edit button is available
      const editButton = screen.getByRole('button', { name: /edit/i });
      expect(editButton).toBeInTheDocument();

      // Step 3: Click Edit button to enable editing mode
      fireEvent.click(editButton);

      // Step 4: Verify that Monaco Editor is displayed for editing
      await waitFor(() => {
        const monacoEditor = screen.getByTestId('monaco-editor');
        expect(monacoEditor).toBeInTheDocument();
        expect(monacoEditor).toHaveAttribute('data-language', 'sql');
        expect(monacoEditor).toHaveAttribute('data-value', originalSQL);
      });

      // Step 5: Verify that the SQL can be edited
      const monacoTextarea = screen.getByTestId('monaco-textarea');
      expect(monacoTextarea).toHaveValue(originalSQL);

      // Edit the SQL by adding a comment
      const editedSQL = `-- Edited query\n${originalSQL}`;
      fireEvent.change(monacoTextarea, { target: { value: editedSQL } });

      // Step 6: Verify that the edited SQL is reflected in the editor
      expect(monacoTextarea).toHaveValue(editedSQL);

      // Step 7: Verify that Execute SQL button is still available with edited SQL
      const executeSQLButton = screen.getByRole('button', { name: /execute sql/i });
      expect(executeSQLButton).toBeInTheDocument();
      expect(executeSQLButton).not.toBeDisabled();

      // Step 8: Execute the edited SQL
      mockOnExecuteSQL.mockResolvedValueOnce({
        columns: ['edited_result'],
        rows: [['edited_test']],
        row_count: 1,
        execution_time_ms: 150,
        truncated: false,
      });

      fireEvent.click(executeSQLButton);

      // Step 9: Verify that the edited SQL is passed to the execution function
      await waitFor(() => {
        expect(mockOnExecuteSQL).toHaveBeenCalledWith(editedSQL);
      });

      unmount();
    }
  });

  it('Property 17: Generated SQL editability - should maintain edit functionality across different SQL types', async () => {
    // Test different types of SQL statements to ensure editability works for all
    const sqlTestCases = [
      {
        type: 'SELECT',
        original: 'SELECT id, name FROM users',
        edited: 'SELECT id, name, email FROM users WHERE active = true',
      },
      {
        type: 'JOIN',
        original: 'SELECT u.name, p.title FROM users u JOIN posts p ON u.id = p.user_id',
        edited: 'SELECT u.name, u.email, p.title, p.created_at FROM users u LEFT JOIN posts p ON u.id = p.user_id',
      },
      {
        type: 'AGGREGATE',
        original: 'SELECT COUNT(*) FROM orders',
        edited: 'SELECT COUNT(*) as total_orders, AVG(amount) as avg_amount FROM orders WHERE status = \'completed\'',
      },
      {
        type: 'SUBQUERY',
        original: 'SELECT * FROM users WHERE id IN (SELECT user_id FROM orders)',
        edited: 'SELECT u.*, COUNT(o.id) as order_count FROM users u WHERE u.id IN (SELECT user_id FROM orders WHERE amount > 100) GROUP BY u.id',
      },
      {
        type: 'COMPLEX',
        original: 'WITH recent_orders AS (SELECT * FROM orders WHERE created_at > NOW() - INTERVAL \'7 days\') SELECT * FROM recent_orders',
        edited: 'WITH recent_orders AS (SELECT user_id, SUM(amount) as total FROM orders WHERE created_at > NOW() - INTERVAL \'7 days\' GROUP BY user_id) SELECT u.name, ro.total FROM users u JOIN recent_orders ro ON u.id = ro.user_id',
      },
    ];

    for (const testCase of sqlTestCases) {
      const mockLLMResult: NaturalLanguageQueryResult = {
        generated_sql: testCase.original,
        columns: ['test'],
        rows: [['data']],
        row_count: 1,
        execution_time_ms: 100,
        truncated: false,
      };

      mockOnSubmit.mockResolvedValueOnce(mockLLMResult);

      const { unmount } = render(
        <NaturalLanguageInput
          onSubmit={mockOnSubmit}
          onExecuteSQL={mockOnExecuteSQL}
        />
      );

      // Generate SQL
      const textarea = screen.getByPlaceholderText(/describe what data you want to see/i);
      fireEvent.change(textarea, { target: { value: `Show ${testCase.type} query` } });

      const submitButton = screen.getByRole('button', { name: /convert to sql/i });
      fireEvent.click(submitButton);

    await waitFor(() => {
      // Look for the Generated SQL card specifically
      expect(screen.getByText('Generated SQL')).toBeInTheDocument();
      // Verify SQL appears in the view mode (pre element)
      const preElement = document.querySelector('pre');
      expect(preElement).toHaveTextContent(testCase.original);
    });

      // Enter edit mode
      const editButton = screen.getByRole('button', { name: /edit/i });
      fireEvent.click(editButton);

      // Verify editor is available with original SQL
      await waitFor(() => {
        const monacoEditor = screen.getByTestId('monaco-editor');
        expect(monacoEditor).toHaveAttribute('data-value', testCase.original);
      });

      // Edit the SQL
      const monacoTextarea = screen.getByTestId('monaco-textarea');
      fireEvent.change(monacoTextarea, { target: { value: testCase.edited } });

      // Verify the edit was applied
      expect(monacoTextarea).toHaveValue(testCase.edited);

      // Execute the edited SQL
      mockOnExecuteSQL.mockResolvedValueOnce({
        columns: ['result'],
        rows: [['edited']],
        row_count: 1,
        execution_time_ms: 120,
        truncated: false,
      });

      const executeSQLButton = screen.getByRole('button', { name: /execute sql/i });
      fireEvent.click(executeSQLButton);

      // Verify edited SQL was executed
      await waitFor(() => {
        expect(mockOnExecuteSQL).toHaveBeenCalledWith(testCase.edited);
      });

      unmount();
    }
  });

  it('Property 17: Generated SQL editability - should toggle between view and edit modes consistently', async () => {
    // Test that the edit/view toggle works consistently for any generated SQL
    const testSQL = 'SELECT * FROM products WHERE price > 100 ORDER BY name';
    
    const mockLLMResult: NaturalLanguageQueryResult = {
      generated_sql: testSQL,
      columns: ['id', 'name', 'price'],
      rows: [[1, 'Product A', 150], [2, 'Product B', 200]],
      row_count: 2,
      execution_time_ms: 85,
      truncated: false,
    };

    mockOnSubmit.mockResolvedValueOnce(mockLLMResult);

    render(
      <NaturalLanguageInput
        onSubmit={mockOnSubmit}
        onExecuteSQL={mockOnExecuteSQL}
      />
    );

    // Generate SQL
    const textarea = screen.getByPlaceholderText(/describe what data you want to see/i);
    fireEvent.change(textarea, { target: { value: 'Show expensive products' } });

    const submitButton = screen.getByRole('button', { name: /convert to sql/i });
    fireEvent.click(submitButton);

    await waitFor(() => {
      // Look for the Generated SQL card specifically
      expect(screen.getByText('Generated SQL')).toBeInTheDocument();
      // Verify SQL appears in the view mode (pre element)
      const preElement = document.querySelector('pre');
      expect(preElement).toHaveTextContent(testSQL);
    });

    const editButton = screen.getByRole('button', { name: /edit/i });

    // Initial state: should be in view mode (pre element visible, no Monaco editor)
    expect(screen.getByText('Generated SQL')).toBeInTheDocument();
    const preElement = document.querySelector('pre');
    expect(preElement).toHaveTextContent(testSQL);
    expect(screen.queryByTestId('monaco-editor')).not.toBeInTheDocument();
    expect(editButton).toHaveTextContent('Edit');

    // Toggle to edit mode
    fireEvent.click(editButton);

    await waitFor(() => {
      expect(screen.getByTestId('monaco-editor')).toBeInTheDocument();
      expect(editButton).toHaveTextContent('View');
    });

    // Verify Monaco editor has the correct SQL
    const monacoEditor = screen.getByTestId('monaco-editor');
    expect(monacoEditor).toHaveAttribute('data-value', testSQL);

    // Toggle back to view mode
    fireEvent.click(editButton);

    await waitFor(() => {
      expect(screen.queryByTestId('monaco-editor')).not.toBeInTheDocument();
      expect(editButton).toHaveTextContent('Edit');
    });

    // Verify pre element is visible again
    const preElementAfterToggle = document.querySelector('pre');
    expect(preElementAfterToggle).toHaveTextContent(testSQL);

    // Toggle to edit mode again
    fireEvent.click(editButton);

    await waitFor(() => {
      expect(screen.getByTestId('monaco-editor')).toBeInTheDocument();
      expect(editButton).toHaveTextContent('View');
    });

    // Make an edit
    const monacoTextarea = screen.getByTestId('monaco-textarea');
    const editedSQL = testSQL + ' LIMIT 10';
    fireEvent.change(monacoTextarea, { target: { value: editedSQL } });

    // Toggle back to view mode - should show edited SQL
    fireEvent.click(editButton);

    await waitFor(() => {
      expect(screen.queryByTestId('monaco-editor')).not.toBeInTheDocument();
      const preElementWithEdit = document.querySelector('pre');
      expect(preElementWithEdit).toHaveTextContent(editedSQL);
      expect(editButton).toHaveTextContent('Edit');
    });
  });

  it('Property 17: Generated SQL editability - should preserve edits during execution', async () => {
    // Test that edited SQL is preserved and used for execution
    const originalSQL = 'SELECT name FROM users';
    const editedSQL = 'SELECT name, email, created_at FROM users WHERE active = true ORDER BY created_at DESC';
    
    const mockLLMResult: NaturalLanguageQueryResult = {
      generated_sql: originalSQL,
      columns: ['name'],
      rows: [['John'], ['Jane']],
      row_count: 2,
      execution_time_ms: 50,
      truncated: false,
    };

    mockOnSubmit.mockResolvedValueOnce(mockLLMResult);

    render(
      <NaturalLanguageInput
        onSubmit={mockOnSubmit}
        onExecuteSQL={mockOnExecuteSQL}
      />
    );

    // Generate original SQL
    const textarea = screen.getByPlaceholderText(/describe what data you want to see/i);
    fireEvent.change(textarea, { target: { value: 'Show user names' } });

    const submitButton = screen.getByRole('button', { name: /convert to sql/i });
    fireEvent.click(submitButton);

    await waitFor(() => {
      // Look for the Generated SQL card specifically
      expect(screen.getByText('Generated SQL')).toBeInTheDocument();
      // Verify SQL appears in the view mode (pre element)
      const preElement = document.querySelector('pre');
      expect(preElement).toHaveTextContent(originalSQL);
    });

    // Enter edit mode and modify SQL
    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);

    await waitFor(() => {
      const monacoTextarea = screen.getByTestId('monaco-textarea');
      fireEvent.change(monacoTextarea, { target: { value: editedSQL } });
    });

    // Execute the edited SQL
    mockOnExecuteSQL.mockResolvedValueOnce({
      columns: ['name', 'email', 'created_at'],
      rows: [['John', 'john@example.com', '2024-01-01'], ['Jane', 'jane@example.com', '2024-01-02']],
      row_count: 2,
      execution_time_ms: 75,
      truncated: false,
    });

    const executeSQLButton = screen.getByRole('button', { name: /execute sql/i });
    fireEvent.click(executeSQLButton);

    // Verify that the edited SQL was executed, not the original
    await waitFor(() => {
      expect(mockOnExecuteSQL).toHaveBeenCalledWith(editedSQL);
      expect(mockOnExecuteSQL).not.toHaveBeenCalledWith(originalSQL);
    });

    // Verify that results are displayed with the edited query
    await waitFor(() => {
      const queryResults = screen.getByTestId('query-results');
      expect(queryResults).toBeInTheDocument();
      expect(screen.getByTestId('results-query')).toHaveTextContent(editedSQL);
    });
  });
});